# BV analyses for Report

March 2017

## Questions

1. Population structure

2. Barriers to gene-flow

3. Colonisation of artificial ponds


## Datasets

#### 1. Natural pops only


Remove all individuals from artificial ponds in vcftools 

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/SumStats
```
vcftools --vcf BV.71.1665.FINAL.vcf --remove names.Art.ponds --recode --recode-INFO-all --out BV46.Naturalponds.1665.vcf
```

46 indivs

7 pops

1665 loci

88.2% genotyping rate



#### 2. Full dataset

71 indivs

10 pops

1665 loci

87.9% genotyping rate


## Analyses

### 1. Summary statistics

Dataset2

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/SumStats/AvgHet

#### 1. AvgHet

AvgHet was calculated before: https://github.com/alexjvr1/BombinaVariegata/blob/57751523f9e249e66d9a3e1933664958a109c771/BombinaFinalAnalyses.md

Remove IBA05_12A from the dataset. Calculate the avg Het and SD per population.
This is in the excel sheet: Bombina.Tables_1070303.xlsx

Plot data from all 71 populations. Colour Artificial and Natural ponds. 
```
BV71.AvgHet.forplot <- read.table("AvgHet.71.forplot", header=T)
colnames(BV71.AvgHet.forplot)
BV71.AvgHet.forplot$pop <- factor(BV71.AvgHet.forplot$pop, levels=BV71.AvgHet.forplot$pop)

q <- qplot(pop, AvgHet, fill=factor((PondType), levels=c("Artificial", "Natural")),
data=BV71.AvgHet.forplot, geom="boxplot")

pdf("Fig1.BV71.AvgHet.pdf")
q + theme_bw()+theme(legend.title=element_blank()) +theme(axis.text.x = element_text(angle = 90, hjust = 1))
dev.off()
```

![alt_txt][Fig1]

[Fig1]:https://cloud.githubusercontent.com/assets/12142475/23587537/bf9b6fb0-01ae-11e7-8418-4ba09fb1f658.png


#### 2. Fis & Heterozygosity

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/SumStats

calculate avg het and Fis overall. Per pop we can calculate H0 and He, but I couldn't get hierfstat to work on the individual pop files
```
library(adegenet)
library(hierfstat)
popnames.BV71 <- pop.BV.71$V2   ##list of popnames that can be read by seppop
popnames.BV71 <- gsub("1.", "", popnames.BV71)
popnames.BV71 <- gsub("2.", "", popnames.BV71)
popnames.BV71 <- gsub("3.", "", popnames.BV71)
popnames.BV71 <- gsub("4.", "", popnames.BV71)
popnames.BV71

BV.71.new <- BV.71  ##new genind file
popnames.BV71.factor <- as.factor(popnames.BV71)  
BV.71.new@pop <- popnames.BV71.factor  #rename pops
BV.71.new

stats.BRU <- summary(BV10pops.adegenet$BRU)   ##calculate summary stats
stats.ZIN <- summary(BV10pops.adegenet$ZIN)
stats.ZIV <- summary(BV10pops.adegenet$ZIV)
stats.NAG <- summary(BV10pops.adegenet$NAG)
stats.WIL <- summary(BV10pops.adegenet$WIL)
stats.HOP <- summary(BV10pops.adegenet$HOP)
stats.CHR <- summary(BV10pops.adegenet$CHR)
stats.IBA <- summary(BV10pops.adegenet$IBA)
stats.HOC <- summary(BV10pops.adegenet$HOC)
stats.UNT <- summary(BV10pops.adegenet$UNT)

mean(stats.BRU$Hobs)
mean(stats.ZIN$Hobs)
mean(stats.ZIV$Hobs)
mean(stats.NAG$Hobs)
mean(stats.WIL$Hobs)
mean(stats.HOP$Hobs)
mean(stats.CHR$Hobs)
mean(stats.IBA$Hobs)
mean(stats.HOC$Hobs)
mean(stats.UNT$Hobs)

hier.BRU <- genind2hierfstat(BV10pops.adegenet$BRU)   ##change to hierfstat format
hier.ZIN <- genind2hierfstat(BV10pops.adegenet$ZIN)
hier.ZIV <- genind2hierfstat(BV10pops.adegenet$ZIV)
hier.NAG <- genind2hierfstat(BV10pops.adegenet$NAG)
hier.WIL <- genind2hierfstat(BV10pops.adegenet$WIL)
hier.HOP <- genind2hierfstat(BV10pops.adegenet$HOP)
hier.CHR <- genind2hierfstat(BV10pops.adegenet$CHR)
hier.IBA <- genind2hierfstat(BV10pops.adegenet$IBA)
hier.HOC <- genind2hierfstat(BV10pops.adegenet$HOC)
hier.UNT <- genind2hierfstat(BV10pops.adegenet$UNT)

hier.BRU.stats <- basic.stats(hier.BRU, diploid=T, digits=2)  ##keep getting an error with these commands
```

All info in table in excel sheet. 


#### 3. Fst

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/SumStats

```
BV.71 <- read.structure("BV.71.1665.str")
BV.71

pop.BV.71 <- read.table("pops4pgdspider", header=F)  ##make sure the populations are numbered "01.DE.B", etc.
BV.10pops.factor <- as.factor(pop.BV.71$V2)
BV.71@pop <- BV.10pops.factor

hier.BV <- genind2hierfstat(BV.71)

BV.fst <- pairwise.fst(BV.71, pop=NULL, res.type=c("dist", "matrix"))

m <- as.matrix(BV.fst)
m2 <- melt(m)[melt(upper.tri(m))$value,]
names(m2)<- c("c1","c2", "distance")


##remove 0.00 at the diagonals from the plot to get the correct scale

BV.fst[BV.fst == 0] <- NA

library(gplots)

shadesOfGrey <- colorRampPalette(c("grey100", "grey0"))  ##define the colourpalette. 

Dend <- read.table("heatmap.popcolours", header=T)  ##list of colour names for each population based on R colour palatte. In alphabetical order (as in genind file)
Dend.Colours <- as.character(Dend$colours.pop)

BV.popnames <- c("BRU", "ZIN", "ZIV", "NAG", "WIL", "HOP", "CHR", "IBA", "HOC", "UNT")

pdf("Fig2.BV71.Fst.pdf")
par(oma=c(1,1,2,1))
heatmap.2(as.matrix(BV.fst), na.rm=T, trace="none", RowSideColors=Dend.Colours, ColSideColors=Dend.Colours, col=shadesOfGrey, labRow=BV.popnames, labCol=F, key.ylab=NA, key.xlab=NA, key.title="Fst Colour Key", keysize=0.9, main="Pairwise Fst BV71: 10pops, 3regions, 1665loci")  ##RowSideColors is for the dendrogram on the row, ColSideColors for the upper dendrogram. Colour order should be the same as the input. The pop order is alphabetical in the output. 
par(fig = c(0, 1, 0, 1), oma = c(0, 0, 0, 0), mar = c(0, 0, 0, 0), new = TRUE)
plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")

popnames.all <- as.character(c("BRU", "ZIN", "Middle", "East"))
legend("bottom", popnames.all, xpd = TRUE, horiz = TRUE, inset = c(0, 0), bty="o", pch=15, col=c("darkorange3", "darkorange2", "darkorchid1", "deepskyblue1"), title="Regions")
dev.off()

```
Figure 2

![alt_txt][Fig2]

[Fig2]:https://cloud.githubusercontent.com/assets/12142475/23588193/24b8afce-01ba-11e7-9dcc-0d806ad6abae.png





### 2. Population structure

I used only the Natural populations for this: 

46 indivs, 7 pops. 

#### 1. DAPC

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/DAPC.NatPops

tutorial-dapc: A tutorial for Discriminant Analysis of Principal Components (DAPC) using adegenet 2.0.0

total variance = (variance between groups) + (variance within groups)

or more simply, denoting X the data matrix:

VAR(X) = B(X) +W(X)

Usual approaches such as Principal Component Analysis (PCA) or Principal Coordinates Analysis (PCoA / MDS) focus on V AR(X). That is, they only describe the global diversity, possibly overlooking differences between groups. On the contrary, DAPC optimizes B(X) while minimizing W(X): it seeks synthetic variables, the discriminant functions, which show differences between groups as best as possible while minimizing variation within clusters.


1. Convert input to str format

Using pgdspider

Create a file with all the pop names. Use a *spid file from one of the previous conversions


2. Read into R

```
library(adegenet)

BV46 <- read.structure("BV46.Naturalponds.1665.str")

 How many genotypes are there? 46

 How many markers are there? 1665

 Which column contains labels for genotypes ('0' if absent)? 1

 Which column contains the population factor ('0' if absent)? 2

 Which other optional columns should be read (press 'return' when done)? 1: 

 Which row contains the marker names ('0' if absent)? 1

 Are genotypes coded by a single row (y/n)? n

 Converting data from a STRUCTURE .stru file to a genind object... 
```

3. estimate the number of clusters

Using k-means. Which finds the number of clusters with minimises W(X) and maximises B(X). Compare using BIC

Run algorithm on PCA transformed data. I.e. reduce the dataset so that it can run faster.

```
grp.BV46 <- find.clusters(BV46, max.n.clust=40)

> choose nr of PCs: 35  ##I try to keep all the PCs

> choose k: 2 ##see figure below


names.7 <- c("NAG", "WIL", "BRU", "IBA", "ZIN", "HOP", "UNT") ##for name order check the order in grp.BV46
names.7 <- as.character(names.7)

pdf("DAPC.BV.k2.pdf")
table.value(table(pop(BV46), grp.BV46$grp), col.lab=paste("cluster", 1:6), row.lab=names.7)
dev.off()

grp.BV46 <- find.clusters(BV46, max.n.clust=40)

> choose nr of PCs: 35  ##I try to keep all the PCs

> choose k: 3 ##see figure below


pdf("DAPC.BV.k3.pdf")
table.value(table(pop(BV46), grp.BV46$grp), col.lab=paste("cluster", 1:6), row.lab=names.7)
dev.off()

dapc1.BV46 <- dapc(BV46, grp.BV46$grp)
scatter(dapc1.BV46)   ##scatter plot only works if more than 2 axes are available (i.e. k > 2)
```

![alt_txt][DAPC.BIC]

[DAPC.BIC]:https://cloud.githubusercontent.com/assets/12142475/24261303/7a34f880-0fee-11e7-988d-b5081f900d73.png



![alt_txt][DAPC.k2.3]

[DAPC.k2.3]:https://cloud.githubusercontent.com/assets/12142475/24261362/a2c54a5c-0fee-11e7-91be-99a4df20fc0a.png





#### 2. sPCA

spatial PCA uses Moran's I to calculate spatial autocorrelation in the dataset. 

http://adegenet.r-forge.r-project.org/files/tutorial-spca.pdf

I'm again using only the natural populations. 

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/sPCA


Data is read into R from structure format. 

Geographic coordinates are entered into the @other tab in the Genind object. 
```
BV.natural <- read.structure("BV.natural.str")
BV.natural.coords <- read.table("BV.natural.coords", header=F)

##Coordinates cannot be exactly the same, so add jitter. 
xy.natural <- as.matrix(BV.natural.coords)
xy.natural <- jitter(xy.natural, fac=2)

BV.natural@other$xy <- NULL   ##add to the other tab in the Genind object
BV.natural@other$xy <- xy.natural.matrix


BV.natural
/// GENIND OBJECT /////////

 // 46 individuals; 1,665 loci; 3,306 alleles; size: 1.4 Mb

 // Basic content
   @tab:  46 x 3306 matrix of allele counts
   @loc.n.all: number of alleles per locus (range: 1-2)
   @loc.fac: locus factor for the 3306 columns of @tab
   @all.names: list of allele names for each locus
   @ploidy: ploidy of each individual  (range: 2-2)
   @type:  codom
   @call: read.structure(file = "BV.natural.str")

 // Optional content
   @pop: population of each individual (group size range: 46-46)
   @other: a list containing: xy 
   
```

sPCA
```
spca.BV.natural <- spca(BV.natural, ask=F, type=1, scannf=F)  ##this calculates distances between coordinates using Delaunay triangulation (type=1)
plot(mySpca)
colorplot(mySpca,cex=3,main="colorplot of mySpca, first global score")
BV.natural@pop
install.packages("akima")
library(akima)
x <- other(BV.natural)$xy[,1]
y <- other(BV.natural)$xy[,2]
temp <- interp(x, y, mySpca$li[,1])
image(temp, col=azur(100))
points(x,y)
interpX <- seq(min(x),max(x),le=200)
interpY <- seq(min(y),max(y),le=200)
temp <- interp(x, y, mySpca$ls[,1], xo=interpX, yo=interpY)
image(temp, col=azur(100))
points(x,y)

```


![alt_txt][spca.BV]

[spca.BV]:https://cloud.githubusercontent.com/assets/12142475/24329991/027ad140-120d-11e7-9fa2-eecf378efb77.png




#### 3. TESS3



The new TESS3 (from Sept 2016) is an R package. 

https://bioshock38.github.io/TESS3_encho_sen/index.html

This changes some things: Missing data now needs to be coded as negative numbers. This is only really done with .str, so I need to figure out a new method of converting input files. 

The R package is still in development, so there isn't support and there are some bugs. 


```
install.packages("devtools")
```

I had problems installing the package due to write issues, so I installed into the local directory: 
```
with_libpaths(new="/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/TESS3.NatPops", install_github("BioShock38/TESS3_encho_sen"))
```
and then move it to the library folder on the laptop (using linux)
```
cp -r tess3r /usr/local/lib/R/3.3/site-library/
```


Convert .vcf to .str using pgdspider.jar
Then redefine the tess2tess3 function (see below). And convert data to TESS3 format
```

#Read data in. Make sure all the columns have headers in the .str file. Change this with nano in linux. 
BV46.str <- read.table("BV.natural.str")


##read in the coords file. Make sure there is an extra line specifying lat, long. 

BV.coords.2 <- read.table("BV.coords.46.2")  ##read in coordinates and check that they are correct. I need two lines for each sample. Do this in excel. 
head(BV.coords.2)
plot(coordinates, pch = 19, cex = .5, 
     xlab = "Longitude (°E)", ylab = "Latitude (°N)")

##Add coords to .str file and reorder

BV46.str$V1668 <- BV.coords.2$V2
BV46.str$V1669 <- BV.coords.2$V1
BV46.str.new <- BV46.str[c(1, 2, 1669, 1668, 3:1667)]   ##reorder columns. Coords need to come after all the extra columns. 

##redefine tess2tess3 (see below) and convert to tess3 format

BV46.new <- tess2tess3(BV46.str.new, TESS=F, diploid=T, FORMAT=2, extra.row=1, extra.column=2)

#Input file in the STRUCTURE format. The genotypic matrix has 46 individuals and 1667 markers. 
#The number of extra rows is 1 and the number of extra columns is 2 .
#Missing alleles are encoded as -9.


##It turns out that the coordinates file with double lines is incorrect. Just add to the converted file: 

BV46.new$coords.46 <- as.matrix(coordinates)

##Run TESS3
obj.BV46 <- tess3(X=BV46.new$X, coord=BV46.new$coords.46, K=1:10, ploidy=2, openMP.core.num=1)
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done


```

Estimate the most likely K 
```
plot(obj.BV46, crossvalid=F, crossentropy=F)

```
This graph does not show a plateau. Usually the optimal K would be chosen as that with the lowest entropy score. See example from vignette: 
https://bioshock38.github.io/TESS3_encho_sen/articles/main-vignette.html


![alt_txt][Tess3.K]

[Tess3.K]:https://cloud.githubusercontent.com/assets/12142475/24329938/b49c351e-120b-11e7-9bb4-9a62873ed0ca.png




Get results for K=2 and K=3 and plot in geographic space. 
```
Qmatrix <- Gettess3res(obj.BV46, K = 2)$Q
K2.plot <- plot(Qmatrix, BV46.new$coords.46, method = "map.max", resolution = c(300,
300), window = NULL, background = TRUE, map.polygon = NULL,
  raster.filename = NULL, interpolation.model = FieldsKrigModel(10),
  col.palette = CreatePalette())  
  
  
Qmatrix.3 <- Gettess3res(obj.BV46, K = 3)$Q
K3.plot <- plot(Qmatrix.3, BV46.new$coords.46, method = "map.max", resolution = c(300,
300), window = NULL, background = TRUE, map.polygon = NULL,
raster.filename = NULL, interpolation.model = FieldsKrigModel(10),
col.palette = CreatePalette())

Qmatrix.4 <- Gettess3res(obj.BV46, K = 4)$Q
K4.plot <- plot(Qmatrix.4, BV46.new$coords.46, method = "map.max", resolution = c(300,
  300), window = NULL, background = TRUE, map.polygon = NULL,
  raster.filename = NULL, interpolation.model = FieldsKrigModel(10),
  col.palette = CreatePalette())
  

pdf("BV46.TESS3.k2.3.pdf")
par(mfrow=c(2,1))
plot(Qmatrix, BV46.new$coords.46, method = "map.max", resolution = c(300,
300), window = NULL, background = TRUE, map.polygon = NULL,
  raster.filename = NULL, interpolation.model = FieldsKrigModel(10),
  col.palette = CreatePalette()) 
K3.plot <- plot(Qmatrix.3, BV46.new$coords.46, method = "map.max", resolution = c(300,
300), window = NULL, background = TRUE, map.polygon = NULL,
raster.filename = NULL, interpolation.model = FieldsKrigModel(10),
col.palette = CreatePalette())
dev.off()
```

![alt_txt][K23]

[K23]:https://cloud.githubusercontent.com/assets/12142475/24329916/5225722e-120b-11e7-84cd-c327e8779091.png





There was an error in the tess2tess3 function:
I had to add rows in to specify coord. This was missign in the function. Redefine the function. 

In the end I was able to define my own coords file, but I did this anyway, because the function failed without some coords input. I could instead comment out the coords bit at the end. (ie. adding $coords into the obj list.)
```
getAnywhere(tess2tess3)
A single object matching ‘tess2tess3’ was found
It was found in the following places
  package:tess3r
  namespace:tess3r
with value

tess2tess3 <- function (dataframe = NULL, TESS = TRUE, diploid = TRUE, FORMAT = 1, 
    extra.row = 0, extra.column = 0) 

{
    if (!diploid & FORMAT == 2) 
        stop("FORMAT = 2 is for diploids only.")
    if (is.null(dataframe)) 
        stop("dataframe cannot be NULL.")
    if (!is.data.frame(dataframe)) 
        stop("dataframe must be a data.frame object.")
    dat = dataframe
    if (TESS == FALSE) {
        if (extra.row > 0) 
            dat = dat[-(1:extra.row), ]
        if (extra.column > 0) 
            dat = dat[, -(1:extra.column)]
        n = dim(dat)[1]
        L = dim(dat)[2]
        if (FORMAT == 1 & diploid == FALSE) {
            n.ind = n
            n.loc = L
            coord = dat[, 1:2]    ##added this row in
            dat = dat[, -(1:2)] ##added this row in
        }
        if (FORMAT == 1 & diploid == TRUE) {
            n.ind = n
            n.loc = L/2
            coord = dat[, 1:2]    ##added this row in
            dat = dat[, -(1:2)]  ##added this row in
        }
        if (FORMAT == 2 & diploid == TRUE) {
            n.ind = n/2
            n.loc = L
            coord = dat[, 1:2]    ##added this row in
            dat = dat[, -(1:2)]  ##added this row in
        }
        cat("Input file in the STRUCTURE format. The genotypic matrix has", 
            n.ind, "individuals and", n.loc, "markers.", "\n")
        cat("The number of extra rows is", extra.row, "and the number of extra columns is", 
            extra.column, ".\n")
    }
    if (TESS == TRUE) {
        if (extra.row > 0) 
            dat = dat[-(1:extra.row), ]
        if (extra.column > 0) 
            dat = dat[, -(1:extra.column)]
        n = dim(dat)[1]
        L = dim(dat)[2]
        if (FORMAT == 1 & diploid == FALSE) {
            n.ind = n
            n.loc = L - 2
            coord = dat[, 1:2]
            dat = dat[, -(1:2)]
        }
        if (FORMAT == 1 & diploid == TRUE) {
            n.ind = n
            n.loc = L/2 - 1
            coord = dat[, 1:2]
            dat = dat[, -(1:2)]
        }
        if (FORMAT == 2 & diploid == TRUE) {
            n.ind = n/2
            n.loc = L - 2
            coord = dat[seq(1, n, by = 2), 1:2]
            dat = dat[, -(1:2)]
        }
        cat("Input file in the TESS format. The genotypic matrix has", 
            n.ind, "individuals and", n.loc, "markers.", "\n")
        cat("The number of extra rows is", extra.row, "and the number of extra columns is", 
            extra.column, ".\n")
    }
    dat = as.matrix(dat)
    unique.dat = unique(as.numeric(dat))
    missing.dat = unique.dat[unique.dat < 0]
    if (length(missing.dat) == 0) 
        cat("The input file contains no missing genotypes.", 
            "\n")
    if (length(missing.dat) == 1) 
        cat("Missing alleles are encoded as", missing.dat, ".\n")
    if (length(missing.dat) > 1) 
        stop("Multiple values for missing data.", "\n")
    L = dim(dat)[2]
    if (FORMAT == 1 & diploid == FALSE) {
        dat.binary = NULL
        for (j in 1:L) {
            allele = sort(unique(dat[, j]))
            for (i in allele[allele >= 0]) dat.binary = cbind(dat.binary, 
                dat[, j] == i)
            LL = dim(dat.binary)[2]
            ind = which(dat[, j] < 0)
            if (length(ind) != 0) {
                dat.binary[ind, (LL - length(allele) + 2):LL] = -9
            }
        }
    }
    if (FORMAT == 1 & diploid == TRUE) {
        dat.2 = matrix(NA, ncol = L/2, nrow = 2 * n)
        for (ii in 1:n) {
            dat.2[2 * ii - 1, ] = dat[ii, seq(1, L, by = 2)]
            dat.2[2 * ii, ] = dat[ii, seq(2, L, by = 2)]
        }
        L = dim(dat.2)[2]
        dat.binary = NULL
        for (j in 1:L) {
            allele = sort(unique(dat.2[, j]))
            for (i in allele[allele >= 0]) dat.binary = cbind(dat.binary, 
                dat.2[, j] == i)
            LL = dim(dat.binary)[2]
            ind = which(dat.2[, j] < 0)
            if (length(ind) != 0) {
                dat.binary[ind, (LL - length(allele) + 2):LL] = -9
            }
        }
    }
    if (FORMAT == 2 & diploid == TRUE) {
        dat.binary = NULL
        for (j in 1:L) {
            allele = sort(unique(dat[, j]))
            for (i in allele[allele >= 0]) dat.binary = cbind(dat.binary, 
                dat[, j] == i)
            LL = dim(dat.binary)[2]
            ind = which(dat[, j] < 0)
            if (length(ind) != 0) {
                dat.binary[ind, (LL - length(allele) + 2):LL] = -9
            }
        }
    }
    n = dim(dat.binary)[1]
    if (diploid == TRUE) {
        n = n/2
        genotype = matrix(NA, nrow = n, ncol = dim(dat.binary)[2])
        for (i in 1:n) {
            genotype[i, ] = dat.binary[2 * i - 1, ] + dat.binary[2 * 
                i, ]
            genotype[i, (genotype[i, ] < 0)] = NA
        }
    }
    if (FORMAT == 1 & diploid == FALSE) {
        genotype = dat.binary
        for (i in 1:n) {
            genotype[i, (genotype[i, ] < 0)] = NA
        }
    }
    return(list(X = as.matrix(genotype), coord = as.matrix(coord)))
}
<environment: namespace:tess3r>



```

#### 4. IBD



#### 5. AMOVA





### 3. Barriers to geneflow


#### 1. EEMS



#### 2. Model




### 4. Colonisation of Artificial Ponds


#### 1. PCA


#### 2. IBD within region


#### 3. AMOVA within region


#### 4. Admixture analysis within region


#### 5. EEMS within region

#### 6. 
