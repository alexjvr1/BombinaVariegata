# BV analyses for Report

March 2017

## Questions

1. Population structure

2. Barriers to gene-flow

3. Colonisation of artificial ponds


## Datasets

#### 1. Natural pops only


Remove all individuals from artificial ponds in vcftools 

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/SumStats
```
vcftools --vcf BV.71.1665.FINAL.vcf --remove names.Art.ponds --recode --recode-INFO-all --out BV46.Naturalponds.1665.vcf
```

46 indivs

7 pops

1665 loci

88.2% genotyping rate



#### 2. Full dataset

71 indivs

10 pops

1665 loci

87.9% genotyping rate


## Analyses

### 1. Summary statistics

Dataset2

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/SumStats/AvgHet

#### 1. AvgHet

AvgHet was calculated before: https://github.com/alexjvr1/BombinaVariegata/blob/57751523f9e249e66d9a3e1933664958a109c771/BombinaFinalAnalyses.md

Remove IBA05_12A from the dataset. Calculate the avg Het and SD per population.
This is in the excel sheet: Bombina.Tables_1070303.xlsx

Plot data from all 71 populations. Colour Artificial and Natural ponds. 
```
BV71.AvgHet.forplot <- read.table("AvgHet.71.forplot", header=T)
colnames(BV71.AvgHet.forplot)
BV71.AvgHet.forplot$pop <- factor(BV71.AvgHet.forplot$pop, levels=BV71.AvgHet.forplot$pop)

q <- qplot(pop, AvgHet, fill=factor((PondType), levels=c("Artificial", "Natural")),
data=BV71.AvgHet.forplot, geom="boxplot")

pdf("Fig1.BV71.AvgHet.pdf")
q + theme_bw()+theme(legend.title=element_blank()) +theme(axis.text.x = element_text(angle = 90, hjust = 1))
dev.off()
```

![alt_txt][Fig1]

[Fig1]:https://cloud.githubusercontent.com/assets/12142475/23587537/bf9b6fb0-01ae-11e7-8418-4ba09fb1f658.png


#### 2. Fis & Heterozygosity

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/SumStats

calculate avg het and Fis overall. Per pop we can calculate H0 and He, but I couldn't get hierfstat to work on the individual pop files
```
library(adegenet)
library(hierfstat)
popnames.BV71 <- pop.BV.71$V2   ##list of popnames that can be read by seppop
popnames.BV71 <- gsub("1.", "", popnames.BV71)
popnames.BV71 <- gsub("2.", "", popnames.BV71)
popnames.BV71 <- gsub("3.", "", popnames.BV71)
popnames.BV71 <- gsub("4.", "", popnames.BV71)
popnames.BV71

BV.71.new <- BV.71  ##new genind file
popnames.BV71.factor <- as.factor(popnames.BV71)  
BV.71.new@pop <- popnames.BV71.factor  #rename pops
BV.71.new

stats.BRU <- summary(BV10pops.adegenet$BRU)   ##calculate summary stats
stats.ZIN <- summary(BV10pops.adegenet$ZIN)
stats.ZIV <- summary(BV10pops.adegenet$ZIV)
stats.NAG <- summary(BV10pops.adegenet$NAG)
stats.WIL <- summary(BV10pops.adegenet$WIL)
stats.HOP <- summary(BV10pops.adegenet$HOP)
stats.CHR <- summary(BV10pops.adegenet$CHR)
stats.IBA <- summary(BV10pops.adegenet$IBA)
stats.HOC <- summary(BV10pops.adegenet$HOC)
stats.UNT <- summary(BV10pops.adegenet$UNT)

mean(stats.BRU$Hobs)
mean(stats.ZIN$Hobs)
mean(stats.ZIV$Hobs)
mean(stats.NAG$Hobs)
mean(stats.WIL$Hobs)
mean(stats.HOP$Hobs)
mean(stats.CHR$Hobs)
mean(stats.IBA$Hobs)
mean(stats.HOC$Hobs)
mean(stats.UNT$Hobs)

hier.BRU <- genind2hierfstat(BV10pops.adegenet$BRU)   ##change to hierfstat format
hier.ZIN <- genind2hierfstat(BV10pops.adegenet$ZIN)
hier.ZIV <- genind2hierfstat(BV10pops.adegenet$ZIV)
hier.NAG <- genind2hierfstat(BV10pops.adegenet$NAG)
hier.WIL <- genind2hierfstat(BV10pops.adegenet$WIL)
hier.HOP <- genind2hierfstat(BV10pops.adegenet$HOP)
hier.CHR <- genind2hierfstat(BV10pops.adegenet$CHR)
hier.IBA <- genind2hierfstat(BV10pops.adegenet$IBA)
hier.HOC <- genind2hierfstat(BV10pops.adegenet$HOC)
hier.UNT <- genind2hierfstat(BV10pops.adegenet$UNT)

hier.BRU.stats <- basic.stats(hier.BRU, diploid=T, digits=2)  ##keep getting an error with these commands
```

All info in table in excel sheet. 


#### 3. Fst

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/SumStats

```
BV.71 <- read.structure("BV.71.1665.str")
BV.71

pop.BV.71 <- read.table("pops4pgdspider", header=F)  ##make sure the populations are numbered "01.DE.B", etc.
BV.10pops.factor <- as.factor(pop.BV.71$V2)
BV.71@pop <- BV.10pops.factor

hier.BV <- genind2hierfstat(BV.71)

BV.fst <- pairwise.fst(BV.71, pop=NULL, res.type=c("dist", "matrix"))

m <- as.matrix(BV.fst)
m2 <- melt(m)[melt(upper.tri(m))$value,]
names(m2)<- c("c1","c2", "distance")


##remove 0.00 at the diagonals from the plot to get the correct scale

BV.fst[BV.fst == 0] <- NA

library(gplots)

shadesOfGrey <- colorRampPalette(c("grey100", "grey0"))  ##define the colourpalette. 

Dend <- read.table("heatmap.popcolours", header=T)  ##list of colour names for each population based on R colour palatte. In alphabetical order (as in genind file)
Dend.Colours <- as.character(Dend$colours.pop)

BV.popnames <- c("BRU", "ZIN", "ZIV", "NAG", "WIL", "HOP", "CHR", "IBA", "HOC", "UNT")

pdf("Fig2.BV71.Fst.pdf")
par(oma=c(1,1,2,1))
heatmap.2(as.matrix(BV.fst), na.rm=T, trace="none", RowSideColors=Dend.Colours, ColSideColors=Dend.Colours, col=shadesOfGrey, labRow=BV.popnames, labCol=F, key.ylab=NA, key.xlab=NA, key.title="Fst Colour Key", keysize=0.9, main="Pairwise Fst BV71: 10pops, 3regions, 1665loci")  ##RowSideColors is for the dendrogram on the row, ColSideColors for the upper dendrogram. Colour order should be the same as the input. The pop order is alphabetical in the output. 
par(fig = c(0, 1, 0, 1), oma = c(0, 0, 0, 0), mar = c(0, 0, 0, 0), new = TRUE)
plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")

popnames.all <- as.character(c("BRU", "ZIN", "Middle", "East"))
legend("bottom", popnames.all, xpd = TRUE, horiz = TRUE, inset = c(0, 0), bty="o", pch=15, col=c("darkorange3", "darkorange2", "darkorchid1", "deepskyblue1"), title="Regions")
dev.off()

```
Figure 2

![alt_txt][Fig2]

[Fig2]:https://cloud.githubusercontent.com/assets/12142475/23588193/24b8afce-01ba-11e7-9dcc-0d806ad6abae.png





### 2. Population structure

I used only the Natural populations for this: 

46 indivs, 7 pops. 

#### 1. DAPC

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/DAPC.NatPops

tutorial-dapc: A tutorial for Discriminant Analysis of Principal Components (DAPC) using adegenet 2.0.0

total variance = (variance between groups) + (variance within groups)

or more simply, denoting X the data matrix:

VAR(X) = B(X) +W(X)

Usual approaches such as Principal Component Analysis (PCA) or Principal Coordinates Analysis (PCoA / MDS) focus on V AR(X). That is, they only describe the global diversity, possibly overlooking differences between groups. On the contrary, DAPC optimizes B(X) while minimizing W(X): it seeks synthetic variables, the discriminant functions, which show differences between groups as best as possible while minimizing variation within clusters.


1. Convert input to str format

Using pgdspider

Create a file with all the pop names. Use a *spid file from one of the previous conversions


2. Read into R

```
library(adegenet)

BV46 <- read.structure("BV46.Naturalponds.1665.str")

 How many genotypes are there? 46

 How many markers are there? 1665

 Which column contains labels for genotypes ('0' if absent)? 1

 Which column contains the population factor ('0' if absent)? 2

 Which other optional columns should be read (press 'return' when done)? 1: 

 Which row contains the marker names ('0' if absent)? 1

 Are genotypes coded by a single row (y/n)? n

 Converting data from a STRUCTURE .stru file to a genind object... 
```

3. estimate the number of clusters

Using k-means. Which finds the number of clusters with minimises W(X) and maximises B(X). Compare using BIC

Run algorithm on PCA transformed data. I.e. reduce the dataset so that it can run faster.

```
grp.BV46 <- find.clusters(BV46, max.n.clust=40)

> choose nr of PCs: 35  ##I try to keep all the PCs

> choose k: 2 ##see figure below


names.7 <- c("NAG", "WIL", "BRU", "IBA", "ZIN", "HOP", "UNT") ##for name order check the order in grp.BV46
names.7 <- as.character(names.7)

pdf("DAPC.BV.k2.pdf")
table.value(table(pop(BV46), grp.BV46$grp), col.lab=paste("cluster", 1:6), row.lab=names.7)
dev.off()

grp.BV46 <- find.clusters(BV46, max.n.clust=40)

> choose nr of PCs: 35  ##I try to keep all the PCs

> choose k: 3 ##see figure below


pdf("DAPC.BV.k3.pdf")
table.value(table(pop(BV46), grp.BV46$grp), col.lab=paste("cluster", 1:6), row.lab=names.7)
dev.off()

dapc1.BV46 <- dapc(BV46, grp.BV46$grp)
scatter(dapc1.BV46)   ##scatter plot only works if more than 2 axes are available (i.e. k > 2)
```

![alt_txt][DAPC.BIC]

[DAPC.BIC]:https://cloud.githubusercontent.com/assets/12142475/24261303/7a34f880-0fee-11e7-988d-b5081f900d73.png



![alt_txt][DAPC.k2.3]

[DAPC.k2.3]:https://cloud.githubusercontent.com/assets/12142475/24261362/a2c54a5c-0fee-11e7-91be-99a4df20fc0a.png





#### 2. sPCA

spatial PCA uses Moran's I to calculate spatial autocorrelation in the dataset. 

http://adegenet.r-forge.r-project.org/files/tutorial-spca.pdf

I'm again using only the natural populations. 

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/sPCA


Data is read into R from structure format. 

Geographic coordinates are entered into the @other tab in the Genind object. 
```
BV.natural <- read.structure("BV.natural.str")
BV.natural.coords <- read.table("BV.natural.coords", header=F)

##Coordinates cannot be exactly the same, so add jitter. 
xy.natural <- as.matrix(BV.natural.coords)
xy.natural <- jitter(xy.natural, fac=2)

BV.natural@other$xy <- NULL   ##add to the other tab in the Genind object
BV.natural@other$xy <- xy.natural.matrix


BV.natural
/// GENIND OBJECT /////////

 // 46 individuals; 1,665 loci; 3,306 alleles; size: 1.4 Mb

 // Basic content
   @tab:  46 x 3306 matrix of allele counts
   @loc.n.all: number of alleles per locus (range: 1-2)
   @loc.fac: locus factor for the 3306 columns of @tab
   @all.names: list of allele names for each locus
   @ploidy: ploidy of each individual  (range: 2-2)
   @type:  codom
   @call: read.structure(file = "BV.natural.str")

 // Optional content
   @pop: population of each individual (group size range: 46-46)
   @other: a list containing: xy 
   
```

Rescale data to remove missing data (which will affect the spca results
```
BV.natural.scaled <- tab(BV.natural, NA.method="mean", freq=T)
BV.natural.scaled <- as.genind(BV.natural.scaled)    ##change to genind object


BV.natural.scaled@other$xy <- xy.natural.matrix   ##add geographic coordinates
```

sPCA
```
mySpca.BVscaled <- spca(obj=BV.natural.scaled, scannf=F, type=1, ask=F)  ##this calculates distances between coordinates using Delaunay triangulation (type=1)


myGtest <- global.rtest(BV.natural.scaled$tab,mySpca.BVscaled$lw,nperm=99)  ##test for global structure
myGtest

Monte-Carlo test
Call: global.rtest(X = BV.natural.scaled$tab, listw = mySpca.BVscaled$lw, 
    nperm = 99)

Observation: 0.02742912 

Based on 99 replicates
Simulated p-value: 0.01 
Alternative hypothesis: greater 

     Std.Obs  Expectation     Variance 
6.027119e+00 2.260179e-02 6.414970e-07 


myLtest <- local.rtest(BV.natural.scaled$tab,mySpca.BVscaled$lw,nperm=99)  ##test for local structure
myLtest

Monte-Carlo test
Call: local.rtest(X = BV.natural.scaled$tab, listw = mySpca.BVscaled$lw, 
    nperm = 99)

Observation: 0.02247401 

Based on 99 replicates
Simulated p-value: 0.77 
Alternative hypothesis: greater 

      Std.Obs   Expectation      Variance 
-7.258446e-01  2.296800e-02  4.631790e-07 


plot(mySpca.BVscaled)
colorplot(mySpca.BVscaled,cex=3,main="colorplot of mySpca, first global score")
BV.natural.scaled@pop
#install.packages("akima")
library(akima)
x <- other(BV.natural.scaled)$xy[,1]
y <- other(BV.natural.scaled)$xy[,2]
temp <- interp(x, y, mySpca.BVscaled$li[,1])
image(temp, col=azur(100))
points(x,y)
interpX <- seq(min(x),max(x),le=200)
interpY <- seq(min(y),max(y),le=200)
temp <- interp(x, y, mySpca.BVscaled$ls[,1], xo=interpX, yo=interpY)
image(temp, col=azur(100))
points(x,y)

pdf("BV.natural.spca.pdf")
plot(mySpca.BVscaled)
dev.off()

```


![alt_txt][spca.BV]

[spca.BV]:https://cloud.githubusercontent.com/assets/12142475/24329991/027ad140-120d-11e7-9fa2-eecf378efb77.png



Check the loadings of alleles on the major PC axes
```
mySpca <- mySpca.BVscaled

myLoadings <- mySpca$c1[,1]^2
library(reshape2)             ##to order the loci by loading on PCaxis 1
myLoadings.melt <- as.matrix(myLoadings)
myLoadings.2 <- myLoadings.melt[order(myLoadings.melt),]
myLoadings.2

pdf("mySpca.orderedLoadings.pdf")
loadingplot(myLoadings.2, xlab="Alleles",
ylab="Weight of the alleles",
main="Contribution of alleles \n to the first sPCA axis")
dev.off()
```

![alt_txt][sPCA.finalfig]

[sPCA.finalfig]:





#### 3. TESS3



The new TESS3 (from Sept 2016) is an R package. 

https://bioshock38.github.io/TESS3_encho_sen/index.html

This changes some things: Missing data now needs to be coded as negative numbers. This is only really done with .str, so I need to figure out a new method of converting input files. 

The R package is still in development, so there isn't support and there are some bugs. 


```
install.packages("devtools")
```

I had problems installing the package due to write issues, so I installed into the local directory: 
```
with_libpaths(new="/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/TESS3.NatPops", install_github("BioShock38/TESS3_encho_sen"))
```
and then move it to the library folder on the laptop (using linux)
```
cp -r tess3r /usr/local/lib/R/3.3/site-library/
```


Convert .vcf to .str using pgdspider.jar
Then redefine the tess2tess3 function (see below). And convert data to TESS3 format
```

#Read data in. Make sure all the columns have headers in the .str file. Change this with nano in linux. 
BV46.str <- read.table("BV.natural.str")


##read in the coords file. Make sure there is an extra line specifying lat, long. 

BV.coords.2 <- read.table("BV.coords.46.2")  ##read in coordinates and check that they are correct. I need two lines for each sample. Do this in excel. 
head(BV.coords.2)
plot(coordinates, pch = 19, cex = .5, 
     xlab = "Longitude (°E)", ylab = "Latitude (°N)")

##Add coords to .str file and reorder

BV46.str$V1668 <- BV.coords.2$V2
BV46.str$V1669 <- BV.coords.2$V1
BV46.str.new <- BV46.str[c(1, 2, 1669, 1668, 3:1667)]   ##reorder columns. Coords need to come after all the extra columns. 

##redefine tess2tess3 (see below) and convert to tess3 format

BV46.new <- tess2tess3(BV46.str.new, TESS=F, diploid=T, FORMAT=2, extra.row=1, extra.column=2)

#Input file in the STRUCTURE format. The genotypic matrix has 46 individuals and 1667 markers. 
#The number of extra rows is 1 and the number of extra columns is 2 .
#Missing alleles are encoded as -9.


##It turns out that the coordinates file with double lines is incorrect. Just add to the converted file: 

BV46.new$coords.46 <- as.matrix(coordinates)

##Run TESS3
obj.BV46 <- tess3(X=BV46.new$X, coord=BV46.new$coords.46, K=1:10, ploidy=2, openMP.core.num=1)
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done
== Computing spectral decomposition of graph laplacian matrix: done
Main loop: done


```

Estimate the most likely K 
```
plot(obj.BV46, crossvalid=F, crossentropy=F)

```
This graph does not show a plateau. Usually the optimal K would be chosen as that with the lowest entropy score. See example from vignette: 
https://bioshock38.github.io/TESS3_encho_sen/articles/main-vignette.html


![alt_txt][Tess3.K]

[Tess3.K]:https://cloud.githubusercontent.com/assets/12142475/24329938/b49c351e-120b-11e7-9bb4-9a62873ed0ca.png




Get results for K=2 and K=3 and plot in geographic space. 
```
Qmatrix <- Gettess3res(obj.BV46, K = 2)$Q
K2.plot <- plot(Qmatrix, BV46.new$coords.46, method = "map.max", resolution = c(300,
300), window = NULL, background = TRUE, map.polygon = NULL,
  raster.filename = NULL, interpolation.model = FieldsKrigModel(10),
  col.palette = CreatePalette())  
  
  
Qmatrix.3 <- Gettess3res(obj.BV46, K = 3)$Q
K3.plot <- plot(Qmatrix.3, BV46.new$coords.46, method = "map.max", resolution = c(300,
300), window = NULL, background = TRUE, map.polygon = NULL,
raster.filename = NULL, interpolation.model = FieldsKrigModel(10),
col.palette = CreatePalette())

Qmatrix.4 <- Gettess3res(obj.BV46, K = 4)$Q
K4.plot <- plot(Qmatrix.4, BV46.new$coords.46, method = "map.max", resolution = c(300,
  300), window = NULL, background = TRUE, map.polygon = NULL,
  raster.filename = NULL, interpolation.model = FieldsKrigModel(10),
  col.palette = CreatePalette())
  

pdf("BV46.TESS3.k2.3.pdf")
par(mfrow=c(2,1))
plot(Qmatrix, BV46.new$coords.46, method = "map.max", resolution = c(300,
300), window = NULL, background = TRUE, map.polygon = NULL,
  raster.filename = NULL, interpolation.model = FieldsKrigModel(10),
  col.palette = CreatePalette()) 
K3.plot <- plot(Qmatrix.3, BV46.new$coords.46, method = "map.max", resolution = c(300,
300), window = NULL, background = TRUE, map.polygon = NULL,
raster.filename = NULL, interpolation.model = FieldsKrigModel(10),
col.palette = CreatePalette())
dev.off()
```

![alt_txt][K23]

[K23]:https://cloud.githubusercontent.com/assets/12142475/24329916/5225722e-120b-11e7-84cd-c327e8779091.png





There was an error in the tess2tess3 function:
I had to add rows in to specify coord. This was missign in the function. Redefine the function. 

In the end I was able to define my own coords file, but I did this anyway, because the function failed without some coords input. I could instead comment out the coords bit at the end. (ie. adding $coords into the obj list.)
```
getAnywhere(tess2tess3)
A single object matching ‘tess2tess3’ was found
It was found in the following places
  package:tess3r
  namespace:tess3r
with value

tess2tess3 <- function (dataframe = NULL, TESS = TRUE, diploid = TRUE, FORMAT = 1, 
    extra.row = 0, extra.column = 0) 

{
    if (!diploid & FORMAT == 2) 
        stop("FORMAT = 2 is for diploids only.")
    if (is.null(dataframe)) 
        stop("dataframe cannot be NULL.")
    if (!is.data.frame(dataframe)) 
        stop("dataframe must be a data.frame object.")
    dat = dataframe
    if (TESS == FALSE) {
        if (extra.row > 0) 
            dat = dat[-(1:extra.row), ]
        if (extra.column > 0) 
            dat = dat[, -(1:extra.column)]
        n = dim(dat)[1]
        L = dim(dat)[2]
        if (FORMAT == 1 & diploid == FALSE) {
            n.ind = n
            n.loc = L
            coord = dat[, 1:2]    ##added this row in
            dat = dat[, -(1:2)] ##added this row in
        }
        if (FORMAT == 1 & diploid == TRUE) {
            n.ind = n
            n.loc = L/2
            coord = dat[, 1:2]    ##added this row in
            dat = dat[, -(1:2)]  ##added this row in
        }
        if (FORMAT == 2 & diploid == TRUE) {
            n.ind = n/2
            n.loc = L
            coord = dat[, 1:2]    ##added this row in
            dat = dat[, -(1:2)]  ##added this row in
        }
        cat("Input file in the STRUCTURE format. The genotypic matrix has", 
            n.ind, "individuals and", n.loc, "markers.", "\n")
        cat("The number of extra rows is", extra.row, "and the number of extra columns is", 
            extra.column, ".\n")
    }
    if (TESS == TRUE) {
        if (extra.row > 0) 
            dat = dat[-(1:extra.row), ]
        if (extra.column > 0) 
            dat = dat[, -(1:extra.column)]
        n = dim(dat)[1]
        L = dim(dat)[2]
        if (FORMAT == 1 & diploid == FALSE) {
            n.ind = n
            n.loc = L - 2
            coord = dat[, 1:2]
            dat = dat[, -(1:2)]
        }
        if (FORMAT == 1 & diploid == TRUE) {
            n.ind = n
            n.loc = L/2 - 1
            coord = dat[, 1:2]
            dat = dat[, -(1:2)]
        }
        if (FORMAT == 2 & diploid == TRUE) {
            n.ind = n/2
            n.loc = L - 2
            coord = dat[seq(1, n, by = 2), 1:2]
            dat = dat[, -(1:2)]
        }
        cat("Input file in the TESS format. The genotypic matrix has", 
            n.ind, "individuals and", n.loc, "markers.", "\n")
        cat("The number of extra rows is", extra.row, "and the number of extra columns is", 
            extra.column, ".\n")
    }
    dat = as.matrix(dat)
    unique.dat = unique(as.numeric(dat))
    missing.dat = unique.dat[unique.dat < 0]
    if (length(missing.dat) == 0) 
        cat("The input file contains no missing genotypes.", 
            "\n")
    if (length(missing.dat) == 1) 
        cat("Missing alleles are encoded as", missing.dat, ".\n")
    if (length(missing.dat) > 1) 
        stop("Multiple values for missing data.", "\n")
    L = dim(dat)[2]
    if (FORMAT == 1 & diploid == FALSE) {
        dat.binary = NULL
        for (j in 1:L) {
            allele = sort(unique(dat[, j]))
            for (i in allele[allele >= 0]) dat.binary = cbind(dat.binary, 
                dat[, j] == i)
            LL = dim(dat.binary)[2]
            ind = which(dat[, j] < 0)
            if (length(ind) != 0) {
                dat.binary[ind, (LL - length(allele) + 2):LL] = -9
            }
        }
    }
    if (FORMAT == 1 & diploid == TRUE) {
        dat.2 = matrix(NA, ncol = L/2, nrow = 2 * n)
        for (ii in 1:n) {
            dat.2[2 * ii - 1, ] = dat[ii, seq(1, L, by = 2)]
            dat.2[2 * ii, ] = dat[ii, seq(2, L, by = 2)]
        }
        L = dim(dat.2)[2]
        dat.binary = NULL
        for (j in 1:L) {
            allele = sort(unique(dat.2[, j]))
            for (i in allele[allele >= 0]) dat.binary = cbind(dat.binary, 
                dat.2[, j] == i)
            LL = dim(dat.binary)[2]
            ind = which(dat.2[, j] < 0)
            if (length(ind) != 0) {
                dat.binary[ind, (LL - length(allele) + 2):LL] = -9
            }
        }
    }
    if (FORMAT == 2 & diploid == TRUE) {
        dat.binary = NULL
        for (j in 1:L) {
            allele = sort(unique(dat[, j]))
            for (i in allele[allele >= 0]) dat.binary = cbind(dat.binary, 
                dat[, j] == i)
            LL = dim(dat.binary)[2]
            ind = which(dat[, j] < 0)
            if (length(ind) != 0) {
                dat.binary[ind, (LL - length(allele) + 2):LL] = -9
            }
        }
    }
    n = dim(dat.binary)[1]
    if (diploid == TRUE) {
        n = n/2
        genotype = matrix(NA, nrow = n, ncol = dim(dat.binary)[2])
        for (i in 1:n) {
            genotype[i, ] = dat.binary[2 * i - 1, ] + dat.binary[2 * 
                i, ]
            genotype[i, (genotype[i, ] < 0)] = NA
        }
    }
    if (FORMAT == 1 & diploid == FALSE) {
        genotype = dat.binary
        for (i in 1:n) {
            genotype[i, (genotype[i, ] < 0)] = NA
        }
    }
    return(list(X = as.matrix(genotype), coord = as.matrix(coord)))
}
<environment: namespace:tess3r>



```

#### 4. IBD

Fst/(1-Fst) vs log.dist(km) - according to Rousset et al. 1997, this is correlated with the effective population density (De) and effective dispersal distance (variance)

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/SumStats

```
##Fst 15 pops -> Fst/(1-Fst)

library(reshape)
library(fields)


m <- as.matrix(BV.fst)
m
m2 <- melt(m)[melt(upper.tri(m))$value,]
names(m2) <- c("c1", "c2", "distance")
m2

tokeep <- c("1", "2", "4", "5", "6", "8", "10")  ##keep only the natural populations
m2.NatPops <- m2[which(m2$c1 %in% tokeep & m2$c2 %in% tokeep ),]  

m2.NatPops$IBD <- m2.NatPops$distance/(1-m2.NatPops$distance)


BV46.coords <- read.table("BV46.pop.coords", header=T)
> BV46.coords
  pop    lat  long
1 BRU 47.013 8.594
2 ZIN 47.028 8.620
3 NAG 47.014 8.622
4 WIL 47.009 8.612
5 HOP 46.997 8.592
6 IBA 47.002 8.648
7 UNT 46.998 8.625

##change the names
m2.NatPops <- m2[which(m2$c1 %in% tokeep & m2$c2 %in% tokeep ),]  
m2.NatPops$IBD <- m2.NatPops$distance/(1-m2.NatPops$distance)

m2.NatPops
m2.NatPops$c1 <- gsub("10", "UNT", m2.NatPops$c1)
m2.NatPops$c1 <- gsub("1", "BRU", m2.NatPops$c1)
m2.NatPops$c1 <- gsub("2", "ZIN", m2.NatPops$c1)
m2.NatPops$c1 <- gsub("4", "NAG", m2.NatPops$c1)
m2.NatPops$c1 <- gsub("5", "WIL", m2.NatPops$c1)
m2.NatPops$c1 <- gsub("6", "HOP", m2.NatPops$c1)
m2.NatPops$c1 <- gsub("7", "CHR", m2.NatPops$c1)
m2.NatPops$c1 <- gsub("8", "IBA", m2.NatPops$c1)

m2.NatPops$c2 <- gsub("10", "UNT", m2.NatPops$c2)
m2.NatPops$c2 <- gsub("1", "BRU", m2.NatPops$c2)
m2.NatPops$c2 <- gsub("2", "ZIN", m2.NatPops$c2)
m2.NatPops$c2 <- gsub("4", "NAG", m2.NatPops$c2)
m2.NatPops$c2 <- gsub("5", "WIL", m2.NatPops$c2)
m2.NatPops$c2 <- gsub("6", "HOP", m2.NatPops$c2)
m2.NatPops$c2 <- gsub("7", "CHR", m2.NatPops$c2)
m2.NatPops$c2 <- gsub("8", "IBA", m2.NatPops$c2)


m2.dist$c1 <- gsub("1", "BRU", m2.dist$c1)
m2.dist$c1 <- gsub("2", "ZIN", m2.dist$c1)
m2.dist$c1 <- gsub("3", "NAG", m2.dist$c1)
m2.dist$c1 <- gsub("4", "WIL", m2.dist$c1)
m2.dist$c1 <- gsub("5", "HOP", m2.dist$c1)
m2.dist$c1 <- gsub("6", "IBA", m2.dist$c1)
m2.dist$c1 <- gsub("7", "UNT", m2.dist$c1)

m2.dist$c2 <- gsub("1", "BRU", m2.dist$c2)
m2.dist$c2 <- gsub("2", "ZIN", m2.dist$c2)
m2.dist$c2 <- gsub("3", "NAG", m2.dist$c2)
m2.dist$c2 <- gsub("4", "WIL", m2.dist$c2)
m2.dist$c2 <- gsub("5", "HOP", m2.dist$c2)
m2.dist$c2 <- gsub("6", "IBA", m2.dist$c2)
m2.dist$c2 <- gsub("7", "UNT", m2.dist$c2)


BVpop_lon.lat <- cbind(BV46.coords$long, BV46.coords$lat)
distance.matrix.BVpop <- rdist.earth(BVpop_lon.lat, miles=F)  ##great circle dist based on the coordinates
m.dist <- as.matrix(distance.matrix.BVpop)
summary(m.dist)

m2.dist <- melt(m.dist)[melt(upper.tri(m.dist))$value,]
names(m2.dist) <- c("c1", "c2", "distance")
summary(m2.dist)
m2.dist$log.km <- log(m2.dist$distance)


pdf("BV46.NatPops.IBD.pdf")
library(MASS)
#dens <- kde2d(m2.NatPops$IBD,m2.dist$log.km, n=10)
#myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(m2.NatPops$IBD~m2.dist$log.km, pch=20,cex=.5, xlab="log Geographic distance (km)", ylab="Fst/(1-Fst)")
#image(dens, col=transp(myPal(10),.7), add=TRUE)
abline(fit <- lm(m2.NatPops$IBD~m2.dist$log.km))
legend("bottomright", bty="n", legend=paste("R2 =", format(summary(fit)$adj.r.squared, digits=4)))  ##and paste R2
title("Isolation by distance plot - BV.NatPops")
dev.off()
```

Test for significance. I need to perform a Mantel test between genetic distance matrix and geographic distance matrix. This should be at the population level. I performed the test using all individuals, but ibd tests are NS for all datasets and using 2 different measures of genetic distance (method 1= nei's genetic distance; method2= euclidean, see adegenet vignette). 
```
#1. Fst distance Matrix of all BV

BV.fst.new <- BV.fst
colnames(BV.fst.new) <- c("BRU", "ZIN", "ZIV", "NAG", "WIL", "HOP", "CHR", "IBA", "HOC", "UNT")
rownames(BV.fst.new) <- c("BRU", "ZIN", "ZIV", "NAG", "WIL", "HOP", "CHR", "IBA", "HOC", "UNT")

#2. Partition into BV31, BV32, BV46 and convert to .dist

BV31.Middle.fst <- BV.fst.new[,c(1,3:6)]
BV31.Middle.fst <- BV31.Middle.fst[c(1,3:6),]
BV31.Middle.fst.dist <- as.dist(BV31.Middle.fst)

BV32.EAST.fst <- BV.fst.new[,7:10]
BV32.EAST.fst <- BV32.EAST.fst[7:10,]
BV32.EAST.fst.dist <- as.dist(BV32.EAST.fst)

BV46.fst <- BV.fst.new[,c(1,2,4,5,6,8,10)]
BV46.fst <- BV46.fst[c(1,2,4,5,6,8,10),]
BV46.fst.dist <- as.dist(BV46.fst)


#3. Load coordinates into R
BV.coords <- read.table("BV.pop.coords", header=T)

#4. Partition into BV31, BV32, BV46

BV31.Middle.coords <- BV.coords[c(1,3:6),]
BV31.Middle.coords.lonlat <- cbind(BV31.Middle.coords$Long, BV31.Middle.coords$Lat)

BV32.EAST.coords <- BV.coords[7:10,]
BV32.EAST.coords.lonlat <- cbind(BV32.EAST.coords$Long, BV32.EAST.coords$Lat)

BV46.coords <- BV.coords[c(1,2,4,5,6,8,10),]
BV46.coords.lonlat <- cbind(BV46.coords$Long, BV46.coords$Lat)


#5. Calculate geographic distances and convert to .dist

BV31.Middle.dist <- rdist.earth(BV31.Middle.coords.lonlat, miles=F)
BV31.Middle.dist <- as.dist(BV31.Middle.dist)

BV32.EAST.dist <- rdist.earth(BV32.EAST.coords.lonlat, miles=F)
BV32.EAST.dist <- as.dist(BV32.EAST.dist)

BV46.dist <- rdist.earth(BV46.coords.lonlat, miles=F)
BV46.dist <- as.dist(BV46.dist)


#6. Perform mantel test
ibd.BV31.Middle <- mantel.randtest(BV31.Middle.fst.dist, BV31.Middle.dist)
ibd.BV31.Middle

#Monte-Carlo test
#Call: mantel.randtest(m1 = BV31.Middle.fst.dist, m2 = BV31.Middle.dist)

#Observation: 0.4351155 

#Based on 999 replicates
#Simulated p-value: 0.084 
#Alternative hypothesis: greater 

#    Std.Obs Expectation    Variance 
# 1.20565454  0.01328723  0.12241244 


ibd.BV32.EAST <- mantel.randtest(BV32.EAST.fst.dist, BV32.EAST.dist)
ibd.BV32.EAST
#Monte-Carlo test
#Call: mantel.randtest(m1 = BV32.EAST.fst.dist, m2 = BV32.EAST.dist)

#Observation: 0.5735005 

#Based on 999 replicates
#Simulated p-value: 0.044 
#Alternative hypothesis: greater 

#     Std.Obs  Expectation     Variance 
# 1.697451072 -0.004735571  0.116042171
 
ibd.BV46 <- mantel.randtest(BV46.fst.dist, BV46.dist) 
ibd.BV46
#Monte-Carlo test
#Call: mantel.randtest(m1 = BV46.fst.dist, m2 = BV46.dist)

#Observation: 0.4025558 

#Based on 999 replicates
#Simulated p-value: 0.091 
#Alternative hypothesis: greater 

#    Std.Obs Expectation    Variance 
#1.329157443 0.005172716 0.089385255 

```

And IBD within region
```
##Middle

tokeep <- c("1", "3", "4", "5", "6")  ##keep pops from middle cluster
m2.Middle <- m2[which(m2$c1 %in% tokeep & m2$c2 %in% tokeep ),] 
m2.Middle$IBD <- m2.Middle$distance/(1-m2.Middle$distance)


Middle.coords <- read.table("Middle.coords", header=T)

##change the names
m2.Middle$c1 <- gsub("1", "BRU", m2.Middle$c1)
m2.Middle$c1 <- gsub("3", "ZIV", m2.Middle$c1)
m2.Middle$c1 <- gsub("4", "NAG", m2.Middle$c1)
m2.Middle$c1 <- gsub("5", "WIL", m2.Middle$c1)
m2.Middle$c1 <- gsub("6", "HOP", m2.Middle$c1)

m2.Middle$c2 <- gsub("1", "BRU", m2.Middle$c2)
m2.Middle$c2 <- gsub("3", "ZIV", m2.Middle$c2)
m2.Middle$c2 <- gsub("4", "NAG", m2.Middle$c2)
m2.Middle$c2 <- gsub("5", "WIL", m2.Middle$c2)
m2.Middle$c2 <- gsub("6", "HOP", m2.Middle$c2)

m2.dist$c1 <- gsub("1", "BRU", m2.dist$c1)
m2.dist$c1 <- gsub("2", "ZIV", m2.dist$c1)
m2.dist$c1 <- gsub("3", "NAG", m2.dist$c1)
m2.dist$c1 <- gsub("4", "WIL", m2.dist$c1)
m2.dist$c1 <- gsub("5", "HOP", m2.dist$c1)

m2.dist$c2 <- gsub("1", "BRU", m2.dist$c2)
m2.dist$c2 <- gsub("2", "ZIV", m2.dist$c2)
m2.dist$c2 <- gsub("3", "NAG", m2.dist$c2)
m2.dist$c2 <- gsub("4", "WIL", m2.dist$c2)
m2.dist$c2 <- gsub("5", "HOP", m2.dist$c2)


BVpop_lon.lat <- cbind(Middle.coords$long, Middle.coords$lat)
distance.matrix.BVpop <- rdist.earth(BVpop_lon.lat, miles=F)  ##great circle dist based on the coordinates
m.dist <- as.matrix(distance.matrix.BVpop)
summary(m.dist)

m2.dist <- melt(m.dist)[melt(upper.tri(m.dist))$value,]
names(m2.dist) <- c("c1", "c2", "distance")
summary(m2.dist)
m2.dist$log.km <- log(m2.dist$distance)


pdf("BV.Middle.IBD.pdf")
library(MASS)
#dens <- kde2d(m2.Middle$IBD,m2.dist$log.km, n=10)
#myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(m2.Middle$IBD~m2.dist$log.km, pch=20,cex=.5, xlab="log Geographic distance (km)", ylab="Fst/(1-Fst)")
#image(dens, col=transp(myPal(10),.7), add=TRUE)
abline(fit <- lm(m2.Middle$IBD~m2.dist$log.km))
legend("bottomright", bty="n", legend=paste("R2 =", format(summary(fit)$adj.r.squared, digits=4)))  ##and paste R2
title("Isolation by distance plot - BV.Middle")
dev.off()
```




```
##EAST

tokeep <- c("7", "8", "9", "10")  ##keep pops from middle cluster
m2.East <- m2[which(m2$c1 %in% tokeep & m2$c2 %in% tokeep ),] 
m2.East$IBD <- m2.East$distance/(1-m2.East$distance)

East.coords <- read.table("East.coords", header=T)

##change the names
m2.East$c1 <- gsub("7", "CHR", m2.Middle$c1)
m2.East$c1 <- gsub("8", "IBA", m2.Middle$c1)
m2.East$c1 <- gsub("9", "HOC", m2.Middle$c1)
m2.East$c1 <- gsub("10", "UNT", m2.Middle$c1)


m2.East$c2 <- gsub("7", "CHR", m2.East$c2)
m2.East$c2 <- gsub("8", "IBA", m2.East$c2)
m2.East$c2 <- gsub("9", "HOC", m2.East$c2)
m2.East$c2 <- gsub("10", "UNT", m2.East$c2)

m2.dist$c1 <- gsub("7", "CHR", m2.dist$c1)
m2.dist$c1 <- gsub("8", "IBA", m2.dist$c1)
m2.dist$c1 <- gsub("9", "HOC", m2.dist$c1)
m2.dist$c1 <- gsub("10", "UNT", m2.dist$c1)

m2.dist$c2 <- gsub("7", "CHR", m2.dist$c2)
m2.dist$c2 <- gsub("8", "IBA", m2.dist$c2)
m2.dist$c2 <- gsub("9", "HOC", m2.dist$c2)
m2.dist$c2 <- gsub("10", "UNT", m2.dist$c2)


BVpop_lon.lat <- cbind(East.coords$long, East.coords$lat)
distance.matrix.BVpop <- rdist.earth(BVpop_lon.lat, miles=F)  ##great circle dist based on the coordinates
m.dist <- as.matrix(distance.matrix.BVpop)
summary(m.dist)

m2.dist <- melt(m.dist)[melt(upper.tri(m.dist))$value,]
names(m2.dist) <- c("c1", "c2", "distance")
summary(m2.dist)
m2.dist$log.km <- log(m2.dist$distance)


pdf("BV.East.IBD.pdf")
library(MASS)
#dens <- kde2d(m2.East$IBD,m2.dist$log.km, n=10)
#myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(m2.East$IBD~m2.dist$log.km, pch=20,cex=.5, xlab="log Geographic distance (km)", ylab="Fst/(1-Fst)")
#image(dens, col=transp(myPal(10),.7), add=TRUE)
abline(fit <- lm(m2.East$IBD~m2.dist$log.km))
legend("bottomright", bty="n", legend=paste("R2 =", format(summary(fit)$adj.r.squared, digits=4)))  ##and paste R2
title("Isolation by distance plot - BV.East")
dev.off()
```


#### 5. AMOVA

http://grunwaldlab.github.io/Population_Genetics_in_R/AMOVA.html


```
library(adegenet)
library(poppr)

BV46.info <- read.table("BV46.info", header=T)
BV46.pop <- as.factor(BV46.info$pop)
BV46.NaturalPonds.genind@pop <- BV46.pop   ##add pop information
BV46.strata <- BV46.info[,c(1,4:5)]  ##from text file. each column has one hierarchy level specified for all individuals. (indiv, pop, region)
BV46.NaturalPonds.genind@other <- BV46.strata 

strata(BV46.NaturalPonds.genind) <- other(BV46.NaturalPonds.genind)

BV46.genclone <- as.genclone(BV46.NaturalPonds.genind)

BV46.amova <- poppr.amova(BV46.genclone, ~region/pop, within=F, quiet=T)

BV46.amova 

$call
ade4::amova(samples = xtab, distances = xdist, structures = xstruct)

$results
                              Df    Sum Sq   Mean Sq
Between region                 2  260.0390 130.01950
Between samples Within region  4  369.3999  92.34998
Within samples                39 2822.4524  72.37057
Total                         45 3451.8913  76.70870

$componentsofcovariance
                                             Sigma          %
Variations  Between region                 2.57201   3.292541
Variations  Between samples Within region  3.17366   4.062740
Variations  Within samples                72.37057  92.644719
Total variations                          78.11624 100.000000

$statphi
                          Phi
Phi-samples-total  0.07355281
Phi-samples-region 0.04201061
Phi-region-total   0.03292541





BV46.amovatest <- randtest(BV46.amova, nrepet=999)

BV46.amovatest

class: krandtest 
Monte-Carlo tests
Call: randtest.amova(xtest = BV46.amova, nrepet = 999)

Number of tests:   3 

Adjustment method for multiple comparisons:   none 
Permutation number:   999 
                        Test      Obs   Std.Obs   Alter Pvalue
1  Variations within samples 72.37057 -8.952223    less  0.001
2 Variations between samples  3.17366  4.836706 greater  0.001
3  Variations between region  2.57201  1.903398 greater  0.050

other elements: adj.method call 


pdf("BV46.AMOVA.pdf")
plot(BV46.amovatest)
dev.off()

```


```
##Randomised test
BV46.new <- BV46.genclone
set.seed(9001)
strata(BV46.new) <- strata(BV46.genclone)[sample(nInd(BV46.genclone)), -1]
head(strata(BV46.new))
head(strata(BV46.genclone))
BV46.new.amova <- poppr.amova(BV46.new, ~region/pop,within=F, quiet=T)

BV46.new.amova   ##now all the variation is within samples and within populations. So no population structure evident. 

$call
ade4::amova(samples = xtab, distances = xdist, structures = xstruct)

$results
                              Df    Sum Sq  Mean Sq
Between region                 2  149.2193 74.60967
Between samples Within region  6  482.4339 80.40564
Within samples                37 2820.2381 76.22265
Total                         45 3451.8913 76.70870

$componentsofcovariance
                                               Sigma           %
Variations  Between region                -0.5808664  -0.7586328
Variations  Between samples Within region  0.9257442   1.2090559
Variations  Within samples                76.2226512  99.5495769
Total variations                          76.5675291 100.0000000

$statphi
                            Phi
Phi-samples-total   0.004504231
Phi-samples-region  0.011999527
Phi-region-total   -0.007586328


BV46.new.amova.test<- randtest(BV46.new.amova, nrepet=999) 

BV46.new.amova.test

class: krandtest 
Monte-Carlo tests
Call: randtest.amova(xtest = BV46.new.amova, nrepet = 999)

Number of tests:   3 

Adjustment method for multiple comparisons:   none 
Permutation number:   999 
                        Test        Obs    Std.Obs   Alter Pvalue
1  Variations within samples 76.2226512 -0.8735780    less  0.182
2 Variations between samples  0.9257442  1.1706621 greater  0.126
3  Variations between region -0.5808664 -0.8293695 greater  0.771

other elements: adj.method call 

pdf("BV46.AMOVA.randomised.pdf")
plot(BV46.new.amova.test)
dev.off()
```






### 3. Barriers to geneflow


#### 1. Monmonier's algorithm

http://adegenet.r-forge.r-project.org/files/tutorial-basics.pdf


```
Monmonier.pops.info <- read.table("Monmonier.pops.info", header=T)
BV38.monmonier <- read.structure("BV38.monmonier.str")   ##created a structure file with only Middle and East pops


BV38.monmonier@pop <- as.factor(Monmonier.pops.info$region)
coords <- Monmonier.pops.info[,c(3,2)]
xy.natural <- as.matrix(coords)
xy.natural <- jitter(xy.natural)  ##add random variation. 
BV38.monmonier@other$xy <- NULL
BV38.monmonier@other$xy <- xy.natural
plot(BV38.monmonier@other$xy)

temp <- BV38.monmonier@pop
levels(temp) <- c(3,5)
temp <- as.numeric(as.character(temp))
plot(BV38.monmonier@other$xy, pch=temp, cex=1.5,xlab='x',ylab='y')
legend("topright",leg=c("East", "Middle"),pch=c(3,5))


D <- dist(BV38.monmonier@tab)
gab <- chooseCN(BV38.monmonier$other$xy,ask=FALSE,type=2)


mon1 <- monmonier(BV38.monmonier@other$xy, D, gab)

pairwise.fst(BV38.monmonier)
           1
2 0.02582893

monmonier.replicate <- replicate(100, pairwise.fst(BV38.monmonier, pop=sample(pop(BV38.monmonier))))
#[1] 0.01732910 0.01754011 0.02001193 0.01758271 0.01773339 0.01714506
# [7] 0.01939015 0.02129705 0.01791359 0.01756319
mean(monmonier.replicate)
#[1] 0.01894682 
 
pco1 <- dudi.pco(D,scannf=FALSE,nf=1)
barplot(pco1$eig,main="Eigenvalues")

D <- dist(pco1$li)
mon1 <- monmonier(BV38.monmonier@other$xy,D,gab)




plot.monmonier(mon1,
add.arrows=FALSE, bwd=10,
sub="Monmonier plot", csub=2)
points(BV38.monmonier$other$xy,
cex=2.5, pch=20, col="red")
text(labels=BV38.monmonier@pop,
cex=3)
legend("bottomright",
leg="Genetic boundaries\n
among populations")
```





#### 3. EEMS - Not used. I couldn't get results to converge 


Website: https://github.com/dipetkov/eems

Tutorial: EEMS-doc.pdf

This analysis is run in the command line (linux). EEMS needs to be downloaded. On the mac, I've saved it here: Applications/eems-master/runeems_snps/

There's an application for SNP and for msat data as part of the eems package. Be sure to use the correct one.

3 input files are needed:

1. pairwise genetic distance

2. polygon of coordinates

3. coords file.

#####1. pairwise genetic distance as calculated with bed2diffs

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/EEMS.NatPops

I first need to create all the plink files and then use the bed2diffs function from EEMS to generate the genetic distance matrix.
```
vcftools --vcf BV46.Naturalponds.1665.vcf.recode.vcf --plink --out BV46.plink 

plink --file BV46.plink --recode --recodeA --out BV46.plink 

plink --file BV46.plink --out BV46.plink --make-bed

/Users/alexjvr/Applications/eems-master/bed2diffs/src-wout-openmp/bed2diffs_v1 --bfile BV46.plink
```

This creates the .diffs file needed. 


#####2. Polygon of coordinates.

Can be obtained here:

http://www.birdtheme.org/useful/v3tool.html



#####3. Coords file

Coordinates for each individual. One line per sample. Two columns.

Same order as in the plink file.



#####Run EEMS

Move all the input files so that they have the same start to the name for specification in the params file. 

```
cp BV46.plink.diffs BV46.nDemes200.diffs
cp BV.natural.coords2 BV46.nDemes200.coords
mv BV71.nDemes200.outer BV46.nDemes200.outer
```


Params file: 

```
datapath = BV46.nDemes200
mcmcpath = BV46-EEMS-nDemes200-chain1
nIndiv = 46
nSites = 1665
nDemes = 200
qVoronoiPr = 0.050000
mrateShape = 0.00100
qrateShape = 0.001000
sigmaShape = 0.001000
qrateScale = 0.500000
mrateScale = 1.000000
sigmaScale = 1.000000
mSeedsProposalS2 = 0.0010000
qSeedsProposalS2 = 1
mEffctProposalS2 = 1.5
qEffctProposalS2 = 0.10000
mrateMuProposalS2 = 2
diploid = true
numMCMCIter = 2000000
numBurnIter = 1000000
numThinIter = 9999
```

I ran the analysis several times and adjusted the hyper-parameters to get the acceptance rate of the proposal variances within the correct range. The authors suggest 10-40% is acceptable (although they accept slightly higher percentages in their example run in the vignette). 

Default values are shown below. The output from the run tells you which parameters to adjust: 

```
datapath = BV46.nDemes200
mcmcpath = BV46-EEMS-nDemes200-chain1
nIndiv = 46
nSites = 1665
nDemes = 200
qVoronoiPr = 0.050000
mrateShape = 0.00100
qrateShape = 0.001000
sigmaShape = 0.001000
qrateScale = 0.500000
mrateScale = 1.000000
sigmaScale = 1.000000
mSeedsProposalS2 = 0.01
qSeedsProposalS2 = 0.1
mEffctProposalS2 = 0.1
qEffctProposalS2 = 0.001
mrateMuProposalS2 = 0.01
diploid = true
numMCMCIter = 2000000
numBurnIter = 1000000
numThinIter = 9999

```


Command to run EEMS

First, find where eems is on the mac, and then run the analsis. 

Run the final analysis 3 times and store data in different folders. Change the location in the params file mcmcpath = 
```
find ~/ -name "runeems_snps"

~/Applications/eems-master/runeems_snps/src/runeems_snps --params params-chain1.ini --seed 123
~/Applications/eems-master/runeems_snps/src/runeems_snps --params params-chain2.ini --seed 378
~/Applications/eems-master/runeems_snps/src/runeems_snps --params params-chain3.ini --seed 948
```



#####Plot EEMS results

There is a companion package in EEMS used to visualise the results in a geographic context. 

This is run in R


```
if (file.exists("~/Applications/eems-master/rEEMSplots")) {
install.packages("rEEMSplots", repos=NULL, type="source")
} else {
stop("Move to the directory that contains the rEEMSplots source to install the package.")
}


eems.results.to.plot = paste(path.package("rEEMSplots"),"~/Applications/eems-master/runeems_snps/src/runeems_snps",sep="")
name.figures.to.save = "EEMS-BV46-rEEMSplots"

if (!file.exists(eems.results.to.plot)) {
stop("Check that the rEEMSplots package is installed without errors.")
}
```


```
##mcmcpath

##name.figures.to.save

##longlat

eems.plots(mcmcpath = eems.results.to.plot,
plotpath = paste(name.figures.to.save,"-default",sep=""),
longlat = TRUE)
```
Passing longlat = FALSE instead of longlat = TRUE has the effect of flipping the x-axis and the y-axis


#### 2. Model




### 4. Colonisation of Artificial Ponds


#### 1. sPCA


#### 2. IBD within region


#### 3. AMOVA within region


#### 4. EEMS within region

#### 5. Unrooted Dendrogram


Fst was low between populations that were closest to the artificial ponds. To visualise this, I constructed an unrooted dendrogram using the program 

I'm constructing a NJ tree using the R package phangorn

Vignette: https://cran.r-project.org/web/packages/phangorn/vignettes/Trees.pdf

/Users/alexjvr/2016RADAnalysis/Bombina/BV234/Analyses_20161128/SumStats
```
#install.packages("phangorn")
library(phangorn)

annot <- read.table("BV71.annot", header=T)

treeNJ <- NJ(BV.fst)  ##Construct a NJ tree of pairwise population Fst. (i.e. distance tree)
treeNJ$tip.label <- BV.names ##change popnames to populations. 
plot(treeNJ, "unrooted", main="NJ")  ##plot the unrooted NJ tree


```

To get bootstrap support for the branches: 

Create consensus sequences for each population using BioEdit: 

Convert vcf to phylip using pgdspider. Then perform mulitple alignments of sequences online (MAFFT). 

Copy the multiple alignments in fasta formate to flashdisk. Align using BioEdit on red HP computer. Generate consensus sequences for each population. Copy onto flashdisk and back to mac. (Remember to replace all "-").



```
Bombina <- fasta2DNAbin("BV71.fasta")

Bombina.fasta <- read.phyDat("BV71.oneindiv.perpop.fasta", format="fasta", type="DNA")   #concensus fasta sequences for each population
##make sure popnames are correct for treeNJ and for the fasta file (Bombina)

pdf("BV71.NJtree.raw.pdf")
plot(treeNJ, "unrooted", show.tip=F, edge.width=2)
title("NJ tree with bootstrap support")
tiplabels(treeNJ$tip.label)
 nodelabels(myBoots, cex=.6)
 dev.off()
```

And using a parsimony tree. 
```
parsimony(treeNJ, Bombina.fasta)
#269




tre.pars <- optim.parsimony(treeNJ, Bombina.fasta)  #Then, optimization of the parsimony is achieved by:
Final p-score 262 after  4 nni operations 

tre.pars
#Phylogenetic tree with 10 tips and 8 internal nodes.
#
#Tip labels:
	#BRU, ZIN, ZIV, NAG, WIL, HOP, ...

#Unrooted; no branch lengths.

myBoots <- boot.phylo(treeNJ, Bombina,  function(BV.fst) (nj(BV.fst)))  ##Bootstrap support



plot(tre.pars, type="unr", show.tip=FALSE, edge.width=2)
title("Maximum-parsimony tree")
tiplabels(tre.pars$tip.label, bg=transp(num2col(annot$year, col.pal=myPal),.7), cex=.5,
fg="transparent")

fit = pml(treeNJ, data=Bombina)
fit 
fitJC <- optim.pml(fit, TRUE)     
bs = bootstrap.pml(fitJC, bs=100, optNni=TRUE,
control = pml.control(trace = 0))   ##calculate bootstrap support

cnet <- consensusNet(bs, p=0.2)
 plot(cnet, "2D", show.edge.label=TRUE)   

```


###5b: Snpphylo (not used - trouble installing)


I'm not convinced that the previous method is the best way to draw a phylogenetic tree from the data. 

Instead I will try the snpphylo pipeline: 

http://chibba.pgml.uga.edu/snphylo/

http://chibba.pgml.uga.edu/snphylo/install_on_osx.html

First install all the necessary packages in Bash: 
```
echo ${HOME} #determine home directory

SNPHYLO_HOME="/Users/alexjvr/snphylo" #create a folder for snphylo

mkdir -p "${SNPHYLO_HOME}/bin"

curl -O http://www.drive5.com/muscle/downloads3.8.31/muscle3.8.31_i86darwin64.tar.gz   #install muscle
tar xvfz muscle3.8.31_i86darwin64.tar.gz -C "${SNPHYLO_HOME}/bin"
ln -sf "${SNPHYLO_HOME}/bin/muscle3.8.31_i86darwin64" "${SNPHYLO_HOME}/bin/muscle.app"

curl -O http://evolution.gs.washington.edu/phylip/download/phylip-3.696.tar.gz  ##download and install phylip (check the version is correct here)
tar xvfz phylip-3.696.tar.gz -C "${SNPHYLO_HOME}"
ln -sf "${SNPHYLO_HOME}/phylip-3.696" "${SNPHYLO_HOME}/phylip"
pushd "${SNPHYLO_HOME}/phylip/src"
cp Makefile.osx Makefile
make install

##Error in executing the above command. I had to set the location of the gcc compiler in the Makefile
nano Makefile
##and set the following at the appropriate place (where prompted): 
CC = /usr/local/gcc-6.1.0/bin/gcc
```
